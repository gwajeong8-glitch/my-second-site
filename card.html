<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Noblesse — Card Editor</title>
<style>
  :root{ --gold:#caa36a; --bg:#0a0a0a; }
  html,body{margin:0;height:100%;font-family:"Nanum Myeongjo",serif;background:#0b0b0b;color:#f6e3b5;}
  .wrap{display:flex;gap:18px;padding:18px;max-width:1200px;margin:0 auto;}
  .canvas-box{background:#0f0f0f;padding:12px;border-radius:10px;box-shadow:0 8px 30px rgba(0,0,0,.6);}
  canvas{display:block;border-radius:8px;background:#000;}
  .controls{width:300px;}
  .controls h3{margin:6px 0 8px;color:var(--gold)}
  .row{margin:8px 0;}
  input[type=text], input[type=number], select {width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:#111;color:#ffd}
  input[type=color]{height:40px;width:100%}
  button{padding:10px;border-radius:10px;border:none;background:linear-gradient(90deg,#ffd776,#cfa310);cursor:pointer;font-weight:700}
  .muted{font-size:13px;color:#ddd;margin-top:6px}
</style>
</head>
<body>
  <div class="wrap">
    <div class="canvas-box">
      <canvas id="cardCanvas" width="1024" height="490"></canvas>
      <div class="muted">캔버스 크기: 1024×490 — 텍스트를 드래그해 위치를 조정하세요. 저장 후 이미지 다운로드</div>
    </div>

    <div class="controls">
      <h3>카드 텍스트 편집</h3>

      <div class="row">
        <label>표시 텍스트</label>
        <input id="txtValue" type="text" value="노블레스">
      </div>

      <div class="row">
        <label>폰트 (계열)</label>
        <select id="fontFamily">
          <option value="Nanum Myeongjo">Nanum Myeongjo</option>
          <option value="Georgia">Georgia</option>
          <option value="serif">serif</option>
          <option value="Arial">Arial</option>
        </select>
      </div>

      <div class="row">
        <label>폰트 크기 (px)</label>
        <input id="fontSize" type="number" value="64" min="12" max="220">
      </div>

      <div class="row">
        <label>폰트 색상</label>
        <input id="fontColor" type="color" value="#ffd27f">
      </div>

      <div class="row">
        <label>VIP 이미지 선택</label>
        <select id="vipSelect">
          <option value="1">VIP 1</option>
          <option value="2">VIP 2</option>
          <option value="3">VIP 3</option>
        </select>
      </div>

      <div class="row">
        <button id="downloadBtn">이미지로 저장</button>
        <button id="resetBtn" style="margin-left:8px;background:#222;color:#fff">초기화</button>
      </div>

      <div class="muted">텍스트 위치: 캔버스에서 직접 드래그. 폰트/색/크기 바꾸면 즉시 반영됩니다.</div>
    </div>
  </div>

<script>
/* --- 경로 규칙 (네가 준 구조에 맞춰져 있음) ---
   bak.png  -> 루트 (card.html과 같은 위치)
   VIP images -> img/vip1.png, img/vip2.png, img/vip3.png
*/

const params = new URLSearchParams(location.search);
const initialVip = params.get('vip') || '1';

const canvas = document.getElementById('cardCanvas');
const ctx = canvas.getContext('2d');

const txtInput = document.getElementById('txtValue');
const fontSizeInput = document.getElementById('fontSize');
const fontFamilySelect = document.getElementById('fontFamily');
const fontColorInput = document.getElementById('fontColor');
const vipSelect = document.getElementById('vipSelect');

vipSelect.value = initialVip;

// image objects
const bg = new Image();
bg.src = "bak.png"; // 루트

const vipImg = new Image();
vipImg.src = `img/vip${vipSelect.value}.png`;

// text object (draggable)
let textObj = {
  text: txtInput.value,
  size: parseInt(fontSizeInput.value,10),
  family: fontFamilySelect.value,
  color: fontColorInput.value,
  x: canvas.width/2,
  y: canvas.height*0.55,
  align: 'center'
};

let isDragging = false;
let dragOffset = {x:0,y:0};

// draw function
function draw(){
  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // background (cover)
  if (bg.complete) {
    // draw center-cropped to exactly 1024x490 (bak.png expected to fit)
    ctx.drawImage(bg, 0, 0, canvas.width, canvas.height);
  } else {
    bg.onload = draw;
  }

  // vip image (on left-bottom or customize)
  if (vipImg.complete) {
    // scale vip image to fit height ~ 320, keep aspect ratio
    const targetH = canvas.height * 0.7;
    const ratio = vipImg.width / vipImg.height;
    const w = targetH * ratio;
    const h = targetH;
    const x = canvas.width - w - 40; // right side
    const y = canvas.height - h - 20;
    ctx.drawImage(vipImg, x, y, w, h);
  } else {
    vipImg.onload = draw;
  }

  // text shadow + gold style
  ctx.save();
  ctx.textAlign = textObj.align;
  ctx.textBaseline = 'middle';

  // create gold-ish fill using gradient
  const fontStr = `${textObj.size}px ${textObj.family}`;
  ctx.font = fontStr;

  // shadow glow
  ctx.shadowColor = 'rgba(0,0,0,0.6)';
  ctx.shadowBlur = 12;
  ctx.lineWidth = Math.max(3, Math.round(textObj.size * 0.06));

  // gold gradient
  const grd = ctx.createLinearGradient(textObj.x - 200, textObj.y - 40, textObj.x + 200, textObj.y + 40);
  grd.addColorStop(0, '#fff0c9');
  grd.addColorStop(0.4, '#ffd27f');
  grd.addColorStop(1, '#b8862b');

  ctx.fillStyle = grd;
  ctx.strokeStyle = 'rgba(0,0,0,0.5)';
  ctx.lineJoin = 'round';
  ctx.miterLimit = 2;
  ctx.strokeText(textObj.text, textObj.x, textObj.y);
  ctx.fillText(textObj.text, textObj.x, textObj.y);

  ctx.restore();
}

// initial draw after images load
bg.onload = () => { vipImg.onload = draw; };
vipImg.onload = draw;

// UI bindings
txtInput.addEventListener('input', ()=>{ textObj.text = txtInput.value; draw(); });
fontSizeInput.addEventListener('input', ()=>{ textObj.size = parseInt(fontSizeInput.value,10); draw(); });
fontFamilySelect.addEventListener('change', ()=>{ textObj.family = fontFamilySelect.value; draw(); });
fontColorInput.addEventListener('input', ()=>{ textObj.color = fontColorInput.value; draw(); });

vipSelect.addEventListener('change', ()=>{
  vipImg.src = `img/vip${vipSelect.value}.png`;
  vipImg.onload = draw;
});

// drag logic on canvas (for text)
canvas.addEventListener('mousedown', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (canvas.width / rect.width);
  const y = (e.clientY - rect.top) * (canvas.height / rect.height);

  // measure text bounds
  ctx.font = `${textObj.size}px ${textObj.family}`;
  const metrics = ctx.measureText(textObj.text);
  const w = metrics.width;
  const h = textObj.size;

  // simple hit test around text center
  const left = textObj.x - w/2;
  const right = textObj.x + w/2;
  const top = textObj.y - h/2;
  const bottom = textObj.y + h/2;

  if (x >= left && x <= right && y >= top && y <= bottom){
    isDragging = true;
    dragOffset.x = x - textObj.x;
    dragOffset.y = y - textObj.y;
  }
});
window.addEventListener('mousemove', (e)=>{
  if (!isDragging) return;
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (canvas.width / rect.width);
  const y = (e.clientY - rect.top) * (canvas.height / rect.height);
  textObj.x = x - dragOffset.x;
  textObj.y = y - dragOffset.y;
  draw();
});
window.addEventListener('mouseup', ()=>{ isDragging = false; });

// download
document.getElementById('downloadBtn').addEventListener('click', ()=>{
  const link = document.createElement('a');
  link.download = `noblesse_card_vip${vipSelect.value}.png`;
  link.href = canvas.toDataURL('image/png');
  link.click();
});

// reset (simple)
document.getElementById('resetBtn').addEventListener('click', ()=>{
  txtInput.value = '노블레스';
  fontSizeInput.value = 64;
  fontFamilySelect.value = 'Nanum Myeongjo';
  fontColorInput.value = '#ffd27f';
  vipSelect.value = initialVip;
  vipImg.src = `img/vip${vipSelect.value}.png`;
  textObj.text = txtInput.value;
  textObj.size = parseInt(fontSizeInput.value,10);
  textObj.family = fontFamilySelect.value;
  textObj.color = fontColorInput.value;
  textObj.x = canvas.width/2;
  textObj.y = canvas.height*0.55;
  draw();
});
</script>
</body>
</html>
